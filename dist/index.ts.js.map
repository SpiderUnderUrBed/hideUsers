{
  "version": 3,
  "sources": ["../src/index.ts", "../../Vencord/src/utils/types.ts"],
  "sourcesContent": ["// import definePlugin from \"@utils/types\";\r\n//import { definePluginSettings } from \"@vencord/types/api/settings\";\r\nimport definePlugin, { OptionType } from \"@utils/types\";\r\n//import { addGlobalContextMenuPatch, GlobalContextMenuPatchCallback, removeContextMenuPatch } from \"@utils/api/ContextMenu/removeContextMenuPatch\";\r\nimport  { addGlobalContextMenuPatch, GlobalContextMenuPatchCallback, removeContextMenuPatch } from \"@utils/api/ContextMenu\";\r\n// const myGlobalContextMenuPatch: removeContextMenuPatch = (navId, children, ...args) => {\r\n//     // You can log navId, args, or manipulate children here\r\n//     console.log('Nav ID:', navId);\r\n//     console.log('Arguments:', args);\r\n\r\n//     // Modify or enhance the context menu items\r\n//     const modifiedChildren = [...children];\r\n// }\r\nconst patchContextMenu: GlobalContextMenuPatchCallback = (navId, children) => () => {\r\n    console.log(navId)\r\n};\r\nexport default definePlugin({\r\n    name: \"hideUser\",\r\n    description: \"This hides a user like friend from DM's and friends page\",\r\n    authors: [{\r\n        name: \"SpiderUnderUrBed\",\r\n        id: 0n\r\n    }],\r\n\r\n    patches: [],\r\n    start() {\r\n        console.log(this.name, \"just started\");\r\n        addGlobalContextMenuPatch(patchContextMenu);\r\n\r\n    },\r\n    stop() {\r\n\r\n    },\r\n});", "/*\n * Vencord, a modification for Discord's desktop app\n * Copyright (c) 2022 Vendicated and contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport { Command } from \"@api/Commands\";\nimport { NavContextMenuPatchCallback } from \"@api/ContextMenu\";\nimport { FluxEvents } from \"@webpack/types\";\nimport { Promisable } from \"type-fest\";\n\n// exists to export default definePlugin({...})\nexport default function definePlugin<P extends PluginDef>(p: P & Record<string, any>) {\n    return p;\n}\n\nexport type ReplaceFn = (match: string, ...groups: string[]) => string;\n\nexport interface PatchReplacement {\n    /** The match for the patch replacement. If you use a string it will be implicitly converted to a RegExp */\n    match: string | RegExp;\n    /** The replacement string or function which returns the string for the patch replacement */\n    replace: string | ReplaceFn;\n    /** A function which returns whether this patch replacement should be applied */\n    predicate?(): boolean;\n}\n\nexport interface Patch {\n    plugin: string;\n    /** A string or RegExp which is only include/matched in the module code you wish to patch. Prefer only using a RegExp if a simple string test is not enough */\n    find: string | RegExp;\n    /** The replacement(s) for the module being patched */\n    replacement: PatchReplacement | PatchReplacement[];\n    /** Whether this patch should apply to multiple modules */\n    all?: boolean;\n    /** Do not warn if this patch did no changes */\n    noWarn?: boolean;\n    /** Only apply this set of replacements if all of them succeed. Use this if your replacements depend on each other */\n    group?: boolean;\n    /** A function which returns whether this patch should be applied */\n    predicate?(): boolean;\n}\n\nexport interface PluginAuthor {\n    name: string;\n    id: BigInt;\n}\n\nexport interface Plugin extends PluginDef {\n    patches?: Patch[];\n    started: boolean;\n    isDependency?: boolean;\n}\n\nexport interface PluginDef {\n    name: string;\n    description: string;\n    authors: PluginAuthor[];\n    start?(): void;\n    stop?(): void;\n    patches?: Omit<Patch, \"plugin\">[];\n    /**\n     * List of commands that your plugin wants to register\n     */\n    commands?: Command[];\n    /**\n     * A list of other plugins that your plugin depends on.\n     * These will automatically be enabled and loaded before your plugin\n     * Generally these will be API plugins\n     */\n    dependencies?: string[],\n    /**\n     * Whether this plugin is required and forcefully enabled\n     */\n    required?: boolean;\n    /**\n     * Whether this plugin should be hidden from the user\n     */\n    hidden?: boolean;\n    /**\n     * Whether this plugin should be enabled by default, but can be disabled\n     */\n    enabledByDefault?: boolean;\n    /**\n     * When to call the start() method\n     * @default StartAt.WebpackReady\n     */\n    startAt?: StartAt,\n    /**\n     * Which parts of the plugin can be tested by the reporter. Defaults to all parts\n     */\n    reporterTestable?: number;\n    /**\n     * Optionally provide settings that the user can configure in the Plugins tab of settings.\n     * @deprecated Use `settings` instead\n     */\n    // TODO: Remove when everything is migrated to `settings`\n    options?: Record<string, PluginOptionsItem>;\n    /**\n     * Optionally provide settings that the user can configure in the Plugins tab of settings.\n     */\n    settings?: DefinedSettings;\n    /**\n     * Check that this returns true before allowing a save to complete.\n     * If a string is returned, show the error to the user.\n     */\n    beforeSave?(options: Record<string, any>): Promisable<true | string>;\n    /**\n     * Allows you to specify a custom Component that will be rendered in your\n     * plugin's settings page\n     */\n    settingsAboutComponent?: React.ComponentType<{\n        tempSettings?: Record<string, any>;\n    }>;\n    /**\n     * Allows you to subscribe to Flux events\n     */\n    flux?: {\n        [E in FluxEvents]?: (event: any) => void | Promise<void>;\n    };\n    /**\n     * Allows you to manipulate context menus\n     */\n    contextMenus?: Record<string, NavContextMenuPatchCallback>;\n    /**\n     * Allows you to add custom actions to the Vencord Toolbox.\n     * The key will be used as text for the button\n     */\n    toolboxActions?: Record<string, () => void>;\n\n    tags?: string[];\n}\n\nexport const enum StartAt {\n    /** Right away, as soon as Vencord initialised */\n    Init = \"Init\",\n    /** On the DOMContentLoaded event, so once the document is ready */\n    DOMContentLoaded = \"DOMContentLoaded\",\n    /** Once Discord's core webpack modules have finished loading, so as soon as things like react and flux are available */\n    WebpackReady = \"WebpackReady\"\n}\n\nexport const enum ReporterTestable {\n    None = 1 << 1,\n    Start = 1 << 2,\n    Patches = 1 << 3,\n    FluxEvents = 1 << 4\n}\n\nexport const enum OptionType {\n    STRING,\n    NUMBER,\n    BIGINT,\n    BOOLEAN,\n    SELECT,\n    SLIDER,\n    COMPONENT,\n}\n\nexport type SettingsDefinition = Record<string, PluginSettingDef>;\nexport type SettingsChecks<D extends SettingsDefinition> = {\n    [K in keyof D]?: D[K] extends PluginSettingComponentDef ? IsDisabled<DefinedSettings<D>> :\n    (IsDisabled<DefinedSettings<D>> & IsValid<PluginSettingType<D[K]>, DefinedSettings<D>>);\n};\n\nexport type PluginSettingDef = (\n    | PluginSettingStringDef\n    | PluginSettingNumberDef\n    | PluginSettingBooleanDef\n    | PluginSettingSelectDef\n    | PluginSettingSliderDef\n    | PluginSettingComponentDef\n    | PluginSettingBigIntDef\n) & PluginSettingCommon;\n\nexport interface PluginSettingCommon {\n    description: string;\n    placeholder?: string;\n    onChange?(newValue: any): void;\n    /**\n     * Whether changing this setting requires a restart\n     */\n    restartNeeded?: boolean;\n    componentProps?: Record<string, any>;\n    /**\n     * Hide this setting from the settings UI\n     */\n    hidden?: boolean;\n    /**\n     * Set this if the setting only works on Browser or Desktop, not both\n     */\n    target?: \"WEB\" | \"DESKTOP\" | \"BOTH\";\n}\ninterface IsDisabled<D = unknown> {\n    /**\n     * Checks if this setting should be disabled\n     */\n    disabled?(this: D): boolean;\n}\ninterface IsValid<T, D = unknown> {\n    /**\n     * Prevents the user from saving settings if this is false or a string\n     */\n    isValid?(this: D, value: T): boolean | string;\n}\n\nexport interface PluginSettingStringDef {\n    type: OptionType.STRING;\n    default?: string;\n}\nexport interface PluginSettingNumberDef {\n    type: OptionType.NUMBER;\n    default?: number;\n}\nexport interface PluginSettingBigIntDef {\n    type: OptionType.BIGINT;\n    default?: BigInt;\n}\nexport interface PluginSettingBooleanDef {\n    type: OptionType.BOOLEAN;\n    default?: boolean;\n}\n\nexport interface PluginSettingSelectDef {\n    type: OptionType.SELECT;\n    options: readonly PluginSettingSelectOption[];\n}\nexport interface PluginSettingSelectOption {\n    label: string;\n    value: string | number | boolean;\n    default?: boolean;\n}\n\nexport interface PluginSettingSliderDef {\n    type: OptionType.SLIDER;\n    /**\n     * All the possible values in the slider. Needs at least two values.\n     */\n    markers: number[];\n    /**\n     * Default value to use\n     */\n    default: number;\n    /**\n     * If false, allow users to select values in-between your markers.\n     */\n    stickToMarkers?: boolean;\n}\n\nexport interface IPluginOptionComponentProps {\n    /**\n     * Run this when the value changes.\n     *\n     * NOTE: The user will still need to click save to apply these changes.\n     */\n    setValue(newValue: any): void;\n    /**\n     * Set to true to prevent the user from saving.\n     *\n     * NOTE: This will not show the error to the user. It will only stop them saving.\n     * Make sure to show the error in your component.\n     */\n    setError(error: boolean): void;\n    /**\n     * The options object\n     */\n    option: PluginSettingComponentDef;\n}\n\nexport interface PluginSettingComponentDef {\n    type: OptionType.COMPONENT;\n    component: (props: IPluginOptionComponentProps) => JSX.Element;\n}\n\n/** Maps a `PluginSettingDef` to its value type */\ntype PluginSettingType<O extends PluginSettingDef> = O extends PluginSettingStringDef ? string :\n    O extends PluginSettingNumberDef ? number :\n    O extends PluginSettingBigIntDef ? BigInt :\n    O extends PluginSettingBooleanDef ? boolean :\n    O extends PluginSettingSelectDef ? O[\"options\"][number][\"value\"] :\n    O extends PluginSettingSliderDef ? number :\n    O extends PluginSettingComponentDef ? any :\n    never;\ntype PluginSettingDefaultType<O extends PluginSettingDef> = O extends PluginSettingSelectDef ? (\n    O[\"options\"] extends { default?: boolean; }[] ? O[\"options\"][number][\"value\"] : undefined\n) : O extends { default: infer T; } ? T : undefined;\n\ntype SettingsStore<D extends SettingsDefinition> = {\n    [K in keyof D]: PluginSettingType<D[K]> | PluginSettingDefaultType<D[K]>;\n};\n\n/** An instance of defined plugin settings */\nexport interface DefinedSettings<\n    Def extends SettingsDefinition = SettingsDefinition,\n    Checks extends SettingsChecks<Def> = {},\n    PrivateSettings extends object = {}\n> {\n    /** Shorthand for `Vencord.Settings.plugins.PluginName`, but with typings */\n    store: SettingsStore<Def> & PrivateSettings;\n    /** Shorthand for `Vencord.PlainSettings.plugins.PluginName`, but with typings */\n    plain: SettingsStore<Def> & PrivateSettings;\n    /**\n     * React hook for getting the settings for this plugin\n     * @param filter optional filter to avoid rerenders for irrelevent settings\n     */\n    use<F extends Extract<keyof Def | keyof PrivateSettings, string>>(filter?: F[]): Pick<SettingsStore<Def> & PrivateSettings, F>;\n    /** Definitions of each setting */\n    def: Def;\n    /** Setting methods with return values that could rely on other settings */\n    checks: Checks;\n    /**\n     * Name of the plugin these settings belong to,\n     * will be an empty string until plugin is initialized\n     */\n    pluginName: string;\n\n    withPrivateSettings<T extends object>(): DefinedSettings<Def, Checks, T>;\n}\n\nexport type PartialExcept<T, R extends keyof T> = Partial<T> & Required<Pick<T, R>>;\n\nexport type IpcRes<V = any> = { ok: true; value: V; } | { ok: false, error: any; };\n\n/* -------------------------------------------- */\n/*             Legacy Options Types             */\n/* -------------------------------------------- */\n\nexport type PluginOptionBase = PluginSettingCommon & IsDisabled;\nexport type PluginOptionsItem =\n    | PluginOptionString\n    | PluginOptionNumber\n    | PluginOptionBoolean\n    | PluginOptionSelect\n    | PluginOptionSlider\n    | PluginOptionComponent;\nexport type PluginOptionString = PluginSettingStringDef & PluginSettingCommon & IsDisabled & IsValid<string>;\nexport type PluginOptionNumber = (PluginSettingNumberDef | PluginSettingBigIntDef) & PluginSettingCommon & IsDisabled & IsValid<number | BigInt>;\nexport type PluginOptionBoolean = PluginSettingBooleanDef & PluginSettingCommon & IsDisabled & IsValid<boolean>;\nexport type PluginOptionSelect = PluginSettingSelectDef & PluginSettingCommon & IsDisabled & IsValid<PluginSettingSelectOption>;\nexport type PluginOptionSlider = PluginSettingSliderDef & PluginSettingCommon & IsDisabled & IsValid<number>;\nexport type PluginOptionComponent = PluginSettingComponentDef & PluginSettingCommon;\n\nexport type PluginNative<PluginExports extends Record<string, (event: Electron.IpcMainInvokeEvent, ...args: any[]) => any>> = {\n    [key in keyof PluginExports]:\n    PluginExports[key] extends (event: Electron.IpcMainInvokeEvent, ...args: infer Args) => infer Return\n    ? (...args: Args) => Return extends Promise<any> ? Return : Promise<Return>\n    : never;\n};\n"],
  "mappings": "8rBAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,ICwBe,SAARC,EAAmDC,EAA4B,CAClF,OAAOA,CACX,CDtBA,IAAAC,EAAmG,4BAS7FC,EAAmD,CAACC,EAAOC,IAAa,IAAM,CAChF,QAAQ,IAAID,CAAK,CACrB,EACOE,EAAQC,EAAa,CACxB,KAAM,WACN,YAAa,2DACb,QAAS,CAAC,CACN,KAAM,mBACN,GAAI,EACR,CAAC,EAED,QAAS,CAAC,EACV,OAAQ,CACJ,QAAQ,IAAI,KAAK,KAAM,cAAc,KACrC,6BAA0BJ,CAAgB,CAE9C,EACA,MAAO,CAEP,CACJ,CAAC",
  "names": ["src_exports", "__export", "src_default", "definePlugin", "p", "import_ContextMenu", "patchContextMenu", "navId", "children", "src_default", "definePlugin"]
}
